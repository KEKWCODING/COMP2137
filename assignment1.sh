#!/bin/bash

#Made by Kaden M. S#200365413.
#This is a script to show a full system report that captures a range of specific system information with one command.

myhostname=$(hostname) #captures the host name associated with the linux system.

mydate=$(date) #captures the current date.

cpu=$(grep -m1 'model name' /proc/cpuinfo | cut -d: -f2 | xargs) #grep -m1 'model name' /proc/cpuinfo finds the first occurence of the CPU model, cut -d: -f2 extracts everything after the colon, xargs trims the leading and trailing spaces.

uptime=$(uptime -p) #uptime shows how the long the system has been running and the -p stands for pretty which formats the uptime output for easier human reading.

source=$(grep '^PRETTY_NAME=' /etc/os-release | cut -d= -f2 | tr -d '"') #/etc/os-release is the text file that contains the key value pairs about the operating system. grep searches for the line that starts with PRETTY_NAME=, the ^ ensure we extract the exact match. cut splits the line into fields using = as the delimiter (-d=) -f2 means get the sceond field. tr is the translate/delete command, -d '"' deletes the double quotes around the output.

ram=$(free -h |awk '/^Mem:/ {print $2}') #free displays memory statistics, -h means human readable showing values in Gigabytes instead of byte values. The awk process the output and looks for the line that starts with Mem: by using /^Mem:/ then prints the second column with $2 which is the total installed RAM.

disks=$(lshw -class disk 2>/dev/null | grep -E 'product:|size:' | paste - - | awk -F: '{print " - " $2}' | xargs) #lshw lists the hardware, -class disk restricts the output to disk-related hardware, 2>/dev/null suppresses error output (in case lshw isnt installed or has no permission), grep -E uses extended regular epression to filter the lines containing either product: or size: information. awk -F: '{print " - "$2}' formats each line with the "-" prepended reducing the need for a sed. paste - - joins pairs of lines (product and size in thids case) into one lone. 

video=$(lshw -class display 2>/dev/null | grep -E 'vendor:|product:' | awk -F: '{print $2}' | xargs) # lashw -class display gets information about diaply adapters(GPUS), grep 'vendor:|product:' filters the vendors and product lines. awk -F '{print $2}' extracts the model name. xargs trims the extra spaces.

defaultInterface=$(ip r | awk '/default/ {print $5}') #ip r shows the routing table, awk '/default/ {print $5}' looks at the loine that starts with default and prints the 5th word which is the interface, in my case ens33.
hostIP=$(ip -o -4 addr show $defaultInterface | awk '{print $4}' | cut -d/ -f1) #ip -o limits to a one line output per interface, -4 shows only ipv4 addresses, addr show $defaultInterface shows IP address for the interface, in my case it shows the ens33 address. awk '{print $4}' extracts the ip address with the mask, the cut -d/ -f1 removes the mask.

gateway=$(ip r | awk '/default/ {print $3}') # ip r shows inthe routing table, awk '/default/ {print $3}' looks and filters the line that start with default, then prints the 3rd word on the lne which is the gateway.

dns=$(resolvectl status | grep 'DNS Servers' | awk '{print $3}') #resolvectl status displays the dns servers, grep 'DNS Servers' filters the DNS Servers line, awk '{print $3}' displays the 3rd word in the line.




cat <<EOF


System Report for $myhostname generated by $USER, on $mydate
 
System Information
------------------
OS: $source
Uptime: $uptime
CPU: $cpu
RAM: $ram
Disk(s): $disks
Video: $video
Host Address: $hostIP
Gateway IP: $gateway
DNS Server: $dns
 
System Status
-------------
Users Logged In: USER,USER,USER...
Disk Space: FREE SPACE FOR LOCAL FILESYSTEMS IN FORMAT: /MOUNTPOINT N
Process Count: N
Load Averages: N, N, N
Listening Network Ports: N, N, N, ...
UFW Status: UFWSTATUS


EOF




